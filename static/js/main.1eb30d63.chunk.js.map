{"version":3,"sources":["assets/2.png","assets/backgrounds/bg_world.gif","board.js","assets/0.png","assets/1.png","index.js"],"names":["Tile","props","tileSprite","value","tile2","src","alt","width","config","TILESIZE","camera","zoom","height","style","position","top","left","Camera","x","INIT_X","y","INIT_Y","offset_x","offset_y","vp_width","vp_height","speed","max_zoom","angle","Board","handleMouseClick","event","type","setState","isMouseDown","lastX","pageX","lastY","pageY","lastDragX","lastDragY","dragAmount","center","getBoardCenter","state","layers","createLayers","isDragging","isPlacing","selectedTile","placeI","placeJ","placeL","l","BOARD_LAYERS","createAndFill2DArray","rows","BOARD_HEIGHT","columns","BOARD_WIDTH","defaultValue","j","i","Vec2D","window","innerWidth","this","innerHeight","floorLayer","length","redraw","offX","offY","e","preventDefault","buttons","mousePos","lastDrag","offset","subtract","updateCamera","direction","newLayers","slice","oldCenterX","getCenter","matrix","cols","grid","Array","dirI","dirJ","xOffset","idx","convertToMap","Math","floor","ty","console","log","screenX","screenY","TILESIZE_Z","TILE_HALF","trunc","layer","map","renderRow","renderTile","scroll","deltaY","render","className","backgroundImage","background","backgroundSize","backgroundRepeat","onMouseDown","onMouseUp","onMouseMove","bind","onWheel","ref","el","getBoundingClientRect","right","bottom","onClick","handleClick","renderLayer","rotate","React","Component","from","Game","document","body","overflow","addEventListener","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.1eb30d63.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/2.3b93bd89.png\";","export default __webpack_public_path__ + \"static/media/bg_world.4fae2a5e.gif\";","import React from 'react';\r\nimport config from './config.json'\r\nimport tile0 from './assets/0.png';\r\nimport tile1 from './assets/1.png';\r\nimport tile2 from './assets/2.png';\r\nimport background from './assets/backgrounds/bg_world.gif';\r\nimport * as Vec2D from 'vector2d';\r\n\r\n/**\r\n * Renders a tile in the map\r\n * @param {props - properties to render the desired tile} props \r\n * @returns \r\n */\r\nfunction Tile(props) {\r\n    var tileSprite = tile0;\r\n    if(props.value === 0)\r\n      return (null);\r\n    if (props.value % 2 === 0)\r\n        tileSprite = tile1;\r\n    else if (props.value % 3 === 0)\r\n        tileSprite = tile2;\r\n    //var rotatedVec = rotateVec2D(props.center.x, props.center.y, 90, new Vec2D.Vector(props.left, props.top))\r\n    return (\r\n        <img src={tileSprite} \r\n        alt=\"iso tile\" \r\n        width={config.TILESIZE*props.camera.zoom}\r\n        height={config.TILESIZE*props.camera.zoom}\r\n        //onClick={props.onClick} \r\n        style={{\r\n        position: 'absolute', \r\n        top: props.top, \r\n        left: props.left}}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * The camera of the board\r\n */\r\nclass Camera {\r\n    x = config.INIT_X;  // current x position of the camera\r\n    y = config.INIT_Y; // current y position of the camera\r\n    offset_x = 0; // the x offset of the board in the page\r\n    offset_y = 0; // the y offset of the board in the page\r\n    vp_width = 0; // the viewport width of the game board\r\n    vp_height = 0; // the viewport height of the game board\r\n    speed = 1; // camera speed\r\n    zoom = 0.5; // current zoom of the camera to the board\r\n    width = 4; // camera width in tiles\r\n    height = 4; // camera height in tiles\r\n    max_zoom = 4; // camera max zoom\r\n    angle = 0; // current camera angle (from 0 to 3 (0, 90, 180 and 270 degrees))\r\n}\r\n\r\n/**\r\n * The component for the game board/map\r\n * responsible for operations related to the tilemap\r\n */\r\nclass Board extends React.Component {\r\n    constructor(props) {\r\n      super(props);   \r\n      // sets game world background\r\n\r\n      this.camera = new Camera();\r\n      // centers camera\r\n      let center = this.getBoardCenter()\r\n      this.camera.x = center.x;\r\n      this.camera.y = center.y;\r\n      this.state = {\r\n        layers: this.createLayers(),\r\n        x: 0,\r\n        y: 0,\r\n        isMouseDown: false,\r\n        isDragging: false,\r\n        isPlacing: true,\r\n        selectedTile: 1,\r\n        placeI: 0,\r\n        placeJ: 0,\r\n        placeL: 0,\r\n        lastX: 0,\r\n        lastY: 0,\r\n        lastDragX: 0,\r\n        lastDragY: 0\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Creates the world map with layers each containing a 2d array/matrix \r\n     * that contains data of a layer/floor of the board\r\n     */\r\n    createLayers() {\r\n      var layers = [];\r\n      for(let l = 0; l < config.BOARD_LAYERS; l++) {\r\n        layers[l] = createAndFill2DArray({rows:config.BOARD_HEIGHT, columns:config.BOARD_WIDTH, defaultValue: '0'});\r\n      }\r\n      return layers;\r\n    }\r\n      \r\n    /**\r\n     * Returns a Vec2D with the coordinates to center isometric map\r\n     */\r\n    getBoardCenter() {\r\n      let j = config.BOARD_WIDTH;\r\n      let i = config.BOARD_HEIGHT;\r\n      return new Vec2D.Vector(window.innerWidth*0.70/2 - config.TILESIZE*this.camera.zoom/2 \r\n                                                        - (j-i)*(config.TILESIZE*this.camera.zoom/2)/2, \r\n                              window.innerHeight*0.95/2 - (i+j)*(config.TILESIZE*this.camera.zoom/4)/2)\r\n    }\r\n\r\n    /**\r\n     * Position camera in order to position isometric tilemap \r\n     * in the center of the screen based on layer 0 (first floor)\r\n     */\r\n    center(floorLayer) {\r\n      let j = floorLayer[0].length;\r\n      let i = floorLayer.length;\r\n      let center = new Vec2D.Vector(window.innerWidth*0.70/2 - config.TILESIZE*this.camera.zoom/2 \r\n                                                        - (j-i)*(config.TILESIZE*this.camera.zoom/2)/2, \r\n                              window.innerHeight*0.95/2 - (i+j)*(config.TILESIZE*this.camera.zoom/4)/2)\r\n      this.camera.x = center.x;\r\n      this.camera.y = center.y;\r\n      this.setState({redraw: true});\r\n    }\r\n\r\n    /**\r\n     * Position center coordinates of the isometric map current position\r\n     * @param {the floorLayer - the layer containing the floor tilemap} floorLayer\r\n     */\r\n    getCenter(floorLayer) {\r\n      let j = floorLayer[0].length;\r\n      let i = floorLayer.length;\r\n      let offX = (j-i)*(config.TILESIZE*this.camera.zoom/2)/2;\r\n      let offY = (i+j)*(config.TILESIZE*this.camera.zoom/4)/2;\r\n      return new Vec2D.Vector(this.camera.x + offX + config.TILESIZE*this.camera.zoom/2, \r\n                                            this.camera.y + offY);\r\n       \r\n      \r\n      //this.camera.x = center.x;\r\n      //this.camera.y = center.y;\r\n      //this.setState({redraw: true});\r\n    }\r\n    \r\n  \r\n    /**\r\n     * Handles mouse up and down events\r\n     * @param {The event that tirggered this callback} event \r\n     */\r\n    handleMouseClick = (event) => {\r\n      if (event.type === \"mousedown\") {\r\n             this.setState({ isMouseDown: true});\r\n             // saves the position last clicked;\r\n             this.setState({lastX: event.pageX, lastY: event.pageY, lastDragX: event.pageX, lastDragY: event.pageY})         \r\n         } else {\r\n             this.setState({ isMouseDown: false, dragAmount: 0});\r\n         }\r\n     }\r\n  \r\n     /**\r\n      * Handles mouse movements events\r\n      * @param {the event data} e \r\n      */\r\n    onMouseMove(e) {\r\n      e.preventDefault()\r\n      this.setState({x: e.pageX, y: e.pageY });\r\n     \r\n      if(this.state.isMouseDown) {\r\n        // drag event\r\n        if(e.buttons === 2) {\r\n          this.setState({isDragging: true, lastDragX: e.pageX, lastDragY: e.pageY});\r\n          // calculates drag direction \r\n          const mousePos = new Vec2D.Vector(e.pageX, e.pageY);\r\n          const lastDrag = new Vec2D.Vector(this.state.lastDragX, this.state.lastDragY);\r\n          const offset = mousePos.subtract(lastDrag)\r\n          // adjusts camera accordingly\r\n          this.updateCamera(offset)\r\n        }\r\n      } else {\r\n        this.setState({isDragging: false});\r\n\r\n        // if user is placing a new tile, updates the projection of where it would go on placement\r\n        if(this.state.isPlacing) {\r\n          \r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Updates camera's current position\r\n     * @param {offset to be added to the camera's current position} offset \r\n     */\r\n    updateCamera(offset) {\r\n      this.camera.x += offset.x;\r\n      this.camera.y += offset.y;    \r\n    }\r\n  \r\n    /**\r\n     * Rotates board in the desired direction orientation\r\n     */\r\n    rotate(direction) {\r\n      const newLayers = this.state.layers.slice();\r\n      const oldCenterX = this.getCenter(newLayers[0]).x;\r\n\r\n      for(let l = 0; l < this.state.layers.length; l++) {\r\n        const matrix = this.state.layers[l].slice();\r\n        const rows = matrix.length, cols = matrix[0].length;\r\n        const grid = [];\r\n        for (let j = 0; j < cols; j++) {\r\n          grid[j] = Array(rows);\r\n        }\r\n        for (let i = 0; i < rows; i++) {\r\n          for (let j = 0; j < cols; j++) {\r\n            let dirI = direction === \"clockwise\" ? rows-i-1 : i; \r\n            let dirJ = direction === \"clockwise\" ? j : cols-j-1;\r\n            grid[j][i] = matrix[dirI][dirJ];\r\n          }\r\n        }\r\n        newLayers[l] = grid.slice();\r\n       }\r\n\r\n       const xOffset = this.getCenter(newLayers[0]).x - oldCenterX;\r\n       this.camera.x -= xOffset;\r\n       this.setState({layers: newLayers});\r\n       \r\n       // updates camera to reflect correct position of rotated grid\r\n       //this.rotateCamera(direction, newLayers[0]);\r\n       \r\n    }\r\n  \r\n    /**\r\n     * adjusts camera to match current board rotation\r\n     */\r\n    rotateCamera(direction, floorLayer) {\r\n      // updates angle\r\n      if(direction === \"clockwise\") {\r\n        this.camera.angle = (this.camera.angle + 1) % 4;\r\n      } else {\r\n        this.camera.angle--;\r\n        if(this.camera.angle < 0)\r\n          this.camera.angle = 3;\r\n      }\r\n  \r\n\r\n     // this.camera.x+= oldCamX;\r\n     // this.camera.y+= oldCamY;\r\n      //this.camera.x = (oldCamX);\r\n      //this.camera.y = (oldCamY);\r\n      // adjusts camera x based on current angle of choice\r\n      if(this.camera.angle === 1) {\r\n       // this.camera.x -= (this.state.layers[0].length*config.TILESIZE*this.camera.zoom/4);\r\n      } else if (this.camera.angle === 2) {\r\n        //this.camera.x += (this.state.layers[0].length*config.TILESIZE*this.camera.zoom)/2;\r\n      } else if (this.camera.angle === 3) {\r\n        //this.camera.x -= (this.state.layers[0].length*config.TILESIZE*this.camera.zoom/4);\r\n      } else {\r\n        //this.camera.x += (this.state.layers[0].length*config.TILESIZE*this.camera.zoom)/2;\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Handles click interactions in the board tiles\r\n     * @param {the x coord of the click to be handled} x \r\n     * @param {the y coord of the click to be handled} y \r\n     */\r\n    handleClick(x, y) {\r\n      if(!this.state.isDragging) {\r\n        const newLayers = this.state.layers.slice();\r\n\r\n        // dont mess with undefined\r\n        if (typeof newLayers == \"undefined\")\r\n          return;\r\n\r\n        // ** scans for hit in the layers starting from the layer at the top\r\n        for(let l = newLayers.length-1; l >= 0; l--) {\r\n          var idx = this.convertToMap(l, this.state.x, this.state.y);\r\n          var i = Math.floor(idx[0]);\r\n          var j = Math.floor(idx[1]);\r\n          \r\n          // dont mess with undefined\r\n          if (typeof newLayers[l] == \"undefined\") {\r\n            console.log(\"undef 1\");\r\n            continue;\r\n          }\r\n          if (typeof newLayers[l][i] == \"undefined\")\r\n          {\r\n            console.log (\"l: \" + l + \" / i: \" + i);\r\n            console.log(\"undef 2\");\r\n            continue;  \r\n          }\r\n          if (typeof newLayers[l][i][j] == \"undefined\") {\r\n            console.log(\"undef 3\");\r\n            continue;\r\n          }\r\n\r\n          // if it hits some block\r\n          if(newLayers[l][i][j] !== 0) {     \r\n            // breaks loop if there is a tile on top of current one\r\n            if(l+1 < newLayers.length)\r\n              if(newLayers[l+1][i][j] !== 0)\r\n                break;\r\n            \r\n            // check if it hits somewhat the top plane of cube\r\n            let ty =(i+j)*(config.TILESIZE*this.camera.zoom/4) + this.camera.y - (l*config.TILESIZE*this.camera.zoom/2);\r\n            let cy = this.state.y - this.camera.y - this.camera.offset_y + (l*config.TILESIZE*this.camera.zoom/2);\r\n            let offsetY = cy - ty;\r\n            if(offsetY < config.TILESIZE*this.camera.zoom/2) {\r\n              newLayers[l][i][j] = 0; // updates it\r\n            }\r\n            break; // break loop\r\n          }\r\n        }\r\n        // updates layers in game state\r\n        this.setState({layers: newLayers});\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Converts coordinates in the screen space (X,Y) of the page\r\n     * to the map coordinates (i,j) of a given layer\r\n     * @param {the l - the layer index to do the conversion accordingly}\r\n     * @param {The x - the x coordinate to be converted to map index j of layer} screenX \r\n     * @param {The y - the y coordinate to be converted to map index i of layer} screenY \r\n     */\r\n    convertToMap(l, screenX, screenY) {\r\n      let TILESIZE_Z = config.TILESIZE * this.camera.zoom;\r\n      let TILE_HALF = TILESIZE_Z / 2;\r\n  \r\n      screenX = screenX - TILE_HALF - this.camera.x - this.camera.offset_x;\r\n      screenY = screenY - this.camera.y - this.camera.offset_y + (l*config.TILESIZE*this.camera.zoom/2);\r\n      let i = Math.trunc((screenY/TILE_HALF) - (screenX/TILESIZE_Z));\r\n      let j = Math.trunc((screenY/TILE_HALF) + (screenX/TILESIZE_Z));\r\n  \r\n      // makes sure we do not pass the map 2darray limits\r\n      if (i < 0) i = 0; if(i>=this.state.layers[l].length) i = this.state.layers[l].length-1;\r\n      if (j < 0) j = 0; if(j>=this.state.layers[l][0].length) j = this.state.layers[l][0].length-1;\r\n  \r\n      return [i, j];\r\n    }\r\n\r\n    /**\r\n     * Renders each layer of the board/map by rendering all of its tiles\r\n     * @param {layer layer - The layer to be rendered} layer \r\n     * @param {the l - the layer index to be rendered} l\r\n     */\r\n    renderLayer(layer, l) {\r\n      return (\r\n        [...Array(layer.length)].map((e, i) => <span key = {i}>{this.renderRow(layer, l, i)}</span>) \r\n      )\r\n    }\r\n  \r\n    /**\r\n     * Renders each row of the board/map by rendering all of its tiles\r\n     * @param {the layer - the layer currently being rendered} layer\r\n     * @param {the l - the index of the layer bein rendered} l\r\n     * @param {The index - the index for the row to be rendered} i \r\n     */\r\n    renderRow(layer, l, i) {\r\n      return (\r\n        [...Array(layer[i].length)].map((e, j) => <span key = {j}>{this.renderTile(layer, l, i, j)}</span>\r\n        )\r\n      )\r\n    }\r\n   \r\n    /**\r\n     * Renders the tile\r\n     * @param {The layer - the layer currently being rendered} layer\r\n     * @param {the l - the index of the layer being rendered} l\r\n     * @param {The i-index of the tile} i \r\n     * @param {The j-index of the tile} j \r\n     */\r\n    renderTile(layer, l, i, j) {\r\n      return (\r\n        <Tile \r\n          value={layer[i][j]} \r\n          //onClick={() => this.handleClick(i, j)}\r\n          camera = {this.camera}\r\n          center = {this.getBoardCenter()}\r\n          top={(i+j)*(config.TILESIZE*this.camera.zoom/4) + this.camera.y - (l*config.TILESIZE*this.camera.zoom/2)}\r\n          left={(j-i)*(config.TILESIZE*this.camera.zoom/2) + this.camera.x}\r\n        />\r\n      )\r\n      \r\n    }\r\n  \r\n    // change zoom based on mwheel\r\n    onWheel (e) {\r\n      let scroll = -e.deltaY/3200;\r\n  \r\n      if((this.camera.zoom + scroll) > 0 && (this.camera.zoom + scroll) <= this.camera.max_zoom) {\r\n        this.camera.zoom += scroll;\r\n        this.setState({render:true});\r\n      }\r\n    }\r\n  \r\n    render() {\r\n\r\n      // let center = this.getCenter(this.state.layers[0]);\r\n\r\n      // var test_top = center.y;\r\n      // var test_left = center.x;\r\n  \r\n      return (\r\n        <div className=\"game-board\" \r\n            style={{ backgroundImage: `url(${background})`,   \r\n                    backgroundSize: 'cover',\r\n                    backgroundRepeat: 'no-repeat',\r\n                  }}\r\n            onMouseDown={ this.handleMouseClick } \r\n            onMouseUp={ this.handleMouseClick } \r\n            onMouseMove={this.onMouseMove.bind(this)}\r\n            onWheel = {this.onWheel.bind(this)}\r\n            ref={el => {\r\n                if (!el) return;\r\n                this.camera.offset_x = el.getBoundingClientRect().left;\r\n                this.camera.offset_y = el.getBoundingClientRect().top;\r\n                this.camera.vp_width = el.getBoundingClientRect().right - el.getBoundingClientRect().left;\r\n                this.camera.vp_height = el.getBoundingClientRect().bottom - el.getBoundingClientRect().top;\r\n              }}\r\n        >\r\n          <div\r\n            onClick={() => this.handleClick(this.state.x, + this.state.y)}>\r\n              {[...Array(this.state.layers.length)].map((e, l) => <span key = {l}>{this.renderLayer(this.state.layers[l], l)}</span>)}  \r\n              {/* { <Tile \r\n                value={1} \r\n                //onClick={() => this.handleClick(i, j)}\r\n                camera = {this.camera}\r\n                center = {this.getBoardCenter()}\r\n                top={test_top}\r\n                left={test_left}\r\n              /> } */}\r\n          </div>\r\n          <button className = \"rotate-button\" onClick={()=>this.rotate(\"anticlockwise\")}>Anti-clockwise</button>\r\n          <button className = \"rotate-button\" onClick={()=>this.rotate(\"clockwise\")}>Clockwise</button>\r\n          <button className = \"center-button\" onClick={()=>this.center(this.state.layers[0])}>Center</button>\r\n        </div>\r\n      );\r\n    }\r\n  }\r\n\r\n  export default Board;\r\n\r\n\r\n    /**\r\n     * Creates and fills multidimensional arrays with \r\n     * a default value\r\n     * Mohammed Ashfaq @ StackOverflow\r\n     * @param rows The number of rows for the array\r\n     * @param columns The number of columns for the array\r\n     * @param defaultValue The default value for each field of the array\r\n     * @returns The newly created multidimensional array populated with the default value\r\n     */\r\n    function createAndFill2DArray({rows, columns, defaultValue}){\r\n        return Array.from({ length:rows }, (e, i) => (\r\n        Array.from({ length:columns }, (e, j)=> i+j)))\r\n    }\r\n\r\n\r\n    /**\r\n     * Rotates a 2d vector around a provided 2d point\r\n     * @param {* cx The x of the rotation center point} cx \r\n     * @param {* cy The y of the rotation center point} cy \r\n     * @param {* degrees The angle to be rotated in degrees} degrees \r\n     * @param {* v The Vector 2D to be rotated around the provided center} v \r\n     * @returns A Vector2D with the result of the rotation \r\n     */\r\n    // function rotateVec2D(cx, cy, degrees, v){\r\n    //     let angle = (Math.PI/180)*degrees;\r\n    //     return new Vec2D.Vector(Math.cos(angle) * (v.x - cx) - Math.sin(angle) * (v.y - cy) + cx,\r\n    //                             Math.sin(angle) * (v.x - cx) + Math.cos(angle) * (v.y - cy) + cy);\r\n    // }","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport Board from './board.js';\r\nimport {FpsView} from \"react-fps\";\r\n\r\nclass Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    document.body.style.overflow = 'hidden';\r\n    window.addEventListener(\"contextmenu\", e => e.preventDefault());\r\n  }\r\n  \r\n  render() {\r\n    return (\r\n      <div className=\"game\" >\r\n        <div>\r\n          <Board />\r\n        </div>\r\n        <div className=\"game-info\">\r\n          <FpsView width={150} height={90} left={900} top={15}/>\r\n          <div>{/* status */}</div>\r\n          <ol>{/* TODO */}</ol>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(\r\n  <Game />,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}